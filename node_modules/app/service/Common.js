'use strict';

angular.module('tangHelper.common', [])
    .factory('getLocalIP', function($q) {
        return function() {
            var df = $q.defer();
            chrome.system.network.getNetworkInterfaces(function(items) {
                df.resolve(items.filter(function(el) {
                    return !~el.address.indexOf('::');
                }));
            });
            return df.promise;
        };
    })
    .factory('confManager', function($q) {
        return {
            set: function(data) {
                var df = $q.defer();
                chrome.storage.local.set({
                    conf: JSON.stringify(data)
                }, function() {
                    if (chrome.runtime.lastError) {
                        console.warn('存储配置失败, %s',
                            chrome.runtime.lastError.message);
                        return df.reject(chrome.runtime.lastError.message);
                    }
                    df.resolve();
                });
                return df.promise;
            },
            get: function() {
                var df = $q.defer();
                chrome.storage.local.get('conf', function(storage) {
                    if (!storage.conf) {
                        console.log('没有找到配置');
                        return df.reject('NotFound');
                    }
                    df.resolve(JSON.parse(storage.conf));
                });
                return df.promise;
            },
            remove: function() {
                var df = $q.defer();
                chrome.storage.local.remove('conf', function() {
                    if (chrome.runtime.lastError) {
                        console.warn('清理配置失败, %s',
                            chrome.runtime.lastError.message);
                        return df.reject(chrome.runtime.lastError.message);
                    }
                    df.resolve();
                });
                return df.promise;
            }
        };
    })
    .factory('connect', function($http, $q, $timeout) {
        return function(minerAddress) {
            var df = $q.defer();
            var startTimestamp = Date.now();
            var count = 0;
            $timeout.cancel(tryToconnect.timer);
            tryToconnect.timer = null;
            tryToconnect();
            return df.promise;

            function tryToconnect() {
                count++;
                $http.get('http://' + minerAddress, {
                    timeout: 1000
                }).then(function(response) {
                    if (response.status === 200) {
                        return df.resolve({
                            millisecondsElasped: Date.now() - startTimestamp,
                            tryTimes: count
                        });
                    }
                    tryToconnect.timer = $timeout(tryToconnect, 500);
                }, function() {
                    tryToconnect.timer = $timeout(tryToconnect, 500);
                });
            }
        };
    });